---
title: "non_phylo_analyses"
author: "Everyone"
date: "3/22/2018"
output: pdf_document
---

matching

```{r}
response_variables$binom<-response_variables$SCIENTIFIC_NAME_tree
df<-left_join(traits,response_variables, by="binom") %>%
  filter(SCIENTIFIC_NAME_tree != "not_treated_as_species")
```


look at the continuous ones
```{r}
library(corrplot)
select_if(df, is.numeric) %>%
  cor(use="pairwise.complete.obs") %>%
  corrplot
```



Logging response cause it is right-skewed and produced crazy residual plots.

```{r}
names(df)
df2 <- df %>%
  # drop columns that we aren't inerested in
  dplyr::select(-brain_size) %>%
filter_all(all_vars(!is.na(.))) 


naive_mod<-lm(log(urban_median)~log(mean_body_size)+log(clutch_size)+iucn_status+feeding_habitat_generalism+brain_residual+Habitat_agricultural+Habitat_grass_shrubland+Habitat_tree_forest+breeding_habitat_generalism+granivore+insectivore+carrion_eater+diet_generalism+plant_eater+movement_class+ground_nesting+hollow_nesting+nest_generalism+breeding+nest_aggregation+feeding_aggregation,data=df2,na.action = "na.fail", weights=(df2$N/df2$unique_localities))
summary(naive_mod)
dim(df2)
```

```{r}
plot(naive_mod)

```



looking at the model in more depth

```{r}
anova(naive_mod)
```

checking for multicolinearity
```{r}
library(car)
vif(naive_mod)
```


and some not-so-quick model selection.  dredge takes a little while because it considers all combinations of predictor variables.

```{r}
#library(MuMIn)
#dredge(naive_mod,trace = TRUE)
modselect<-step(naive_mod)
```



```{r}
library(visreg)
visreg(modselect)
```


another type of potential model selection


```{r}
library(leaps)

model_all_select <- regsubsets(log(urban_median)~log(mean_body_size)+log(clutch_size)+iucn_status+feeding_habitat_generalism+brain_residual+Habitat_agricultural+Habitat_grass_shrubland+Habitat_tree_forest+breeding_habitat_generalism+granivore+insectivore+carrion_eater+diet_generalism+plant_eater+movement_class+ground_nesting+hollow_nesting+nest_generalism+breeding+nest_aggregation+feeding_aggregation,data=df2,na.action = "na.fail", weights=(df2$N/df2$unique_localities), method = "exhaustive")

results <- summary(model_all_select)

which.max(results$adjr2)

which.min(results$bic)

which.min(results$cp)


```

```{r}
df3 <- df2 %>%
  mutate(response = log(urban_median)) %>%
  mutate(body_size_logged = log(mean_body_size)) %>%
  mutate(clutch_size_logged = log(clutch_size))
```

a model averaging approach
small model first

```{r}
glob.mod <- lm(response~body_size_logged+clutch_size_logged+feeding_habitat_generalism+brain_residual+Habitat_agricultural,data=df3,na.action="na.fail",weights=(df3$N/df3$unique_localities))

library(arm)

stdz.model <- standardize(glob.mod)
model.set <- dredge(stdz.model) 

model.set

#### selects all models with deltaAic < 4
top.models <- get.models(model.set, cumsum(weight) <= 0.95) 

#### how many top models
length(top.models)

#### Ranks these models based on AICc
my.models <- model.sel(top.models, rank="AICc") 

 #### Prints the top models (selected above)
print.data.frame(my.models, digits=2)

Averaged_models <- model.avg(top.models)

summary(Averaged_models)
confint(Averaged_models, full=TRUE)
```


run a parallel version
```{r}
library(snow)
clusterType <- if(length(find.package("snow", quiet = TRUE))) "SOCK" else "PSOCK"
clust <- try(makeCluster(getOption("cl.cores", 10), type = clusterType))

clusterExport(clust, "df3")

glob.mod <- lm(response~body_size_logged+clutch_size_logged+feeding_habitat_generalism+brain_residual+Habitat_agricultural,data=df3,na.action="na.fail",weights=(df3$N/df3$unique_localities))

library(arm)

stdz.model <- standardize(glob.mod)

model.set <- pdredge(stdz.model, cluster=clust) 

model.set

#### selects all models with deltaAic < 4
top.models <- get.models(model.set, cumsum(weight) <= 0.95) 

#### how many top models
length(top.models)

#### Ranks these models based on AICc
my.models <- model.sel(top.models, rank="AICc") 

#### Prints the top models (selected above)
print.data.frame(my.models, digits=2)

Averaged_models <- model.avg(top.models)

summary(Averaged_models)
confint(Averaged_models, full=TRUE)

```

Now repeat on the full model (will take a while so let it run overnight)
```{r}
library(snow)
clusterType <- if(length(find.package("snow", quiet = TRUE))) "SOCK" else "PSOCK"
clust <- try(makeCluster(getOption("cl.cores", 10), type = clusterType))

clusterExport(clust, "df3")

glob.mod <- lm(response ~ body_size_logged + clutch_size_logged + feeding_habitat_generalism + brain_residual + Habitat_agricultural +
                 breeding_habitat_generalism + granivore + insectivore + carrion_eater + plant_eater + diet_generalism + movement_class +
                 ground_nesting + hollow_nesting + nest_generalism + breeding + nest_aggregation + feeding_aggregation + Habitat_grass_shrubland +
                 Habitat_tree_forest, data=df3, na.action = "na.fail", weights=(df3$N/df3$unique_localities))


library(arm)

stdz.model <- standardize(glob.mod)


model.set <- pdredge(stdz.model, m.lim=c(0, 11), cluster=clust, extra="R^2") 

model.set

#### selects all models with deltaAic < 4
top.models <- get.models(model.set, subset=delta<4) 

#### how many top models
length(top.models)

#### Ranks these models based on AICc
my.models <- model.sel(top.models, rank="AICc") 

#### Prints the top models (selected above)
print.data.frame(my.models, digits=2)

Averaged_models <- model.avg(top.models)

summary(Averaged_models)
confint(Averaged_models, full=TRUE)

#### Re-rank the models based on BIC
my.models_BIC <- model.sel(top.models, rank="BIC") 

#### Prints the top models (selected above)
print.data.frame(my.models_BIC, digits=2)

Averaged_models_BIC <- model.avg(top.models)

summary(Averaged_models_BIC)
confint(Averaged_models_BIC, full=TRUE)


```











