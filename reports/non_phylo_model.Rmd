---
title: "non_phylo_analyses"
author: "Everyone"
date: "3/22/2018"
output: pdf_document
---


matching

```{r}
response_variables$binom<-response_variables$SCIENTIFIC_NAME_tree
df<-left_join(traits,response_variables, by="binom") %>%
  filter(SCIENTIFIC_NAME_tree != "not_treated_as_species")
```


look at the continuous ones
```{r}
library(corrplot)
select_if(df, is.numeric) %>%
  cor(use="pairwise.complete.obs") %>%
  corrplot
```



Logging response cause it is right-skewed and produced crazy residual plots.

```{r}
names(df)
df2 <- df %>%
  # drop columns that we aren't inerested in
  dplyr::select(-brain_size) %>%
filter_all(all_vars(!is.na(.))) 


naive_mod<-lm(log(urban_median)~log(mean_body_size)+log(clutch_size)+iucn_status+feeding_habitat_generalism+brain_residual+Habitat_agricultural+Habitat_grass_shrubland+Habitat_tree_forest+breeding_habitat_generalism+granivore+insectivore+carrion_eater+diet_generalism+plant_eater+movement_class+ground_nesting+hollow_nesting+nest_generalism+breeding+nest_aggregation+feeding_aggregation,data=df2,na.action = "na.fail", weights=(df2$N/df2$unique_localities))
summary(naive_mod)
dim(df2)
```

```{r}
plot(naive_mod)

```



looking at the model in more depth

```{r}
anova(naive_mod)
```

checking for multicolinearity
```{r}
library(car)
vif()
```


and some not-so-quick model selection.  dredge takes a little while because it considers all combinations of predictor variables.

```{r}
#library(MuMIn)
#dredge(naive_mod,trace = TRUE)
modselect<-step(naive_mod)
```



```{r}
library(visreg)
visreg(modselect)
```


another type of potential model selection


```{r}
library(leaps)

model_all_select <- regsubsets(log(urban_median)~log(mean_body_size)+log(clutch_size)+iucn_status+feeding_habitat_generalism+brain_residual+Habitat_agricultural+Habitat_grass_shrubland+Habitat_tree_forest+breeding_habitat_generalism+granivore+insectivore+carrion_eater+diet_generalism+plant_eater+movement_class+ground_nesting+hollow_nesting+nest_generalism+breeding+nest_aggregation+feeding_aggregation,data=df2,na.action = "na.fail", weights=(df2$N/df2$unique_localities), method = "exhaustive")

results <- summary(model_all_select)

which.max(results$adjr2)

which.min(results$bic)

which.min(results$cp)


```



a model averaging approach
```{r}
#### Automated Approach ####
#### Computes all possible subsets of global model
df3 <- df2 %>%
  mutate(response = log(urban_median)) %>%
  mutate(body_size_logged = log(mean_body_size)) %>%
  mutate(clutch_size_logged = log(clutch_size))


glob.mod <- lm(response~body_size_logged + clutch_size_logged + feeding_habitat_generalism + brain_residual + Habitat_agricultural,
               data=df3, na.action = "na.fail", weights=(df3$N/df3$unique_localities))

library(arm)
stdz.model <- standardize(glob.mod)


model.set <- dredge(stdz.model) 

model.set

#### selects all models with deltaAic < 4
top.models <- get.models(model.set, cumsum(weight) <= 0.95) 

#### how many top models
length(top.models)

#### Ranks these models based on AICc
my.models <- model.sel(top.models, rank="AICc") 

 #### Prints the top models (selected above)
print.data.frame(my.models, digits=2)

Averaged_models <- model.avg(top.models)

summary(Averaged_models)
confint(Averaged_models, full=TRUE)
```


Now repeat on the full model (will take a while so let it run overnight)
```{r}
df3 <- df2 %>%
  mutate(response = log(urban_median)) %>%
  mutate(body_size_logged = log(mean_body_size)) %>%
  mutate(clutch_size_logged = log(clutch_size))

glob.mod <- lm(response ~ body_size_logged + clutch_size_logged + feeding_habitat_generalism + brain_residual + Habitat_agricultural +
                 breeding_habitat_generalism + granivore + insectivore + carrion_eater + plant_eater + diet_generalism + movement_class +
                 groun_nesting + hollow_nesting + nest_generalism + breeding + nest_aggregation + feeding_aggregation + Habitat_grass_shrubland +
                 Habitat_tree_forest, data=df3, na.action = "na.fail", weights=(df3$N/df3$unique_localities))

library(arm)
stdz.model <- standardize(glob.mod)


model.set <- dredge(stdz.model, extra="R^2") 

model.set

#### selects all models with deltaAic < 4
top.models <- get.models(model.set, cumsum(weight) <= 0.95) 

#### how many top models
length(top.models)

#### Ranks these models based on AICc
my.models <- model.sel(top.models, rank="AICc") 

 #### Prints the top models (selected above)
print.data.frame(my.models, digits=2)

Averaged_models <- model.avg(top.models)

summary(Averaged_models)
confint(Averaged_models, full=TRUE)


```










